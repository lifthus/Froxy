package config

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"
)

// Config is proxy server configuration.
type Config struct {
	Port   string `json:"port,omitempty"`
	Target string `json:"target,omitempty"`
}

// ReadConfig takes command line arguments to read and set the configuration.
// After parsing, it returns the configuration.
// If no arguments are passed, it reads the default config file.
// If there is no config file, it generates the config template file.
// "args" must exclude the program name.
func ReadConfig(args []string) (*Config, error) {
	conf := &Config{
		Port:   "",
		Target: "",
	}
	argnum := 0
	for i := 0; i < len(args); i++ {
		switch args[i] {
		// port config, which specifies the port number to listen to.
		case "-p", "--port":
			if i+1 >= len(args) {
				break
			}
			_, err := strconv.Atoi(args[i+1])
			if err != nil {
				break
			}
			conf.Port = args[i+1]
			if err != nil {
				break
			}
			i++
			argnum++
			continue
		// target config, which specifies the target http server.
		case "-t", "--target":
			if i+1 >= len(args) {
				break
			}
			conf.Target = args[i+1]
			i++
			argnum++
			continue
		}
		return nil, fmt.Errorf("invalid argument %s", args[i])
	}
	if argnum != 2 && argnum != 0 {
		return nil, fmt.Errorf("invalid number of arguments")
	}
	// if no arguments are passsed, read the default config file.
	if conf.Port == "" && conf.Target == "" {
		return readOrGenConfFile(conf)
	}
	return conf, nil
}

// ReadOrGenConfFile handles the case where any of required arguments are not passed.
// It first tries reading the default config file. If the file doesn't exist, it generates the config template file.
func readOrGenConfFile(cf *Config) (*Config, error) {
	// first read the default config file.
	confB, err := os.ReadFile("froxyconfig.json")
	// if doesn't exist, generate the config template.
	if os.IsNotExist(err) {
		return nil, generateConfigTemplate()
	} else if err != nil {
		return nil, fmt.Errorf("failed to read config file:%v", err)
	}

	confI := make(map[string]interface{})
	err = json.Unmarshal(confB, &confI)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshalling the config file:%v", err)
	}

	readPort, ok1 := confI["port"].(string)
	readTarget, ok2 := confI["target"].(string)
	if !ok1 || !ok2 {
		return nil, fmt.Errorf("invalid config file")
	}

	cf.Port = readPort
	cf.Target = readTarget

	err = validateConf(*cf)
	if err != nil {
		return nil, fmt.Errorf("invalid config file:%v", err)
	}
	return cf, nil
}

// validateConf validates each configuration whether it is valid or not.
func validateConf(cf Config) error {
	return nil
}

// froxyConfigTemplate is the template for the config file,
// which is generated by GenerateConfigTemplate().
var froxyConfigTemplate = `{
	"port": "8888",
	"target": "https://www.example.com"
}`

// generateConfigTemplate generates the config template json file.
func generateConfigTemplate() error {
	err := os.WriteFile("froxyconfig.json", []byte(froxyConfigTemplate), 0644)
	if err != nil {
		return fmt.Errorf("failed to generate config file template:%v", err)
	}
	return fmt.Errorf("config file template generated")
}
